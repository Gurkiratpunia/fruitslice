<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand-Track Fruit Ninja</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: -1; }
        
        /* UI Layers */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* HUD */
        .hud-top { display: flex; justify-content: space-between; padding: 20px; font-size: 24px; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.8); font-weight: bold; }
        .score-box span { color: #ffd700; }
        .lives-box span { color: #ff4444; font-size: 30px; }
        
        /* Screens */
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; backdrop-filter: blur(5px); z-index: 10; }
        .hidden { display: none !important; }
        
        h1 { color: #fff; font-size: 60px; margin: 0 0 20px 0; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 20px #ff0055; }
        p { color: #ddd; font-size: 18px; max-width: 600px; text-align: center; line-height: 1.5; }
        
        button { margin-top: 30px; padding: 15px 40px; font-size: 24px; background: linear-gradient(45deg, #ff0055, #ff9900); border: none; color: white; border-radius: 50px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; text-transform: uppercase; font-weight: bold; }
        button:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255, 100, 0, 0.6); }
        
        #loading { color: white; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; }
    </style>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Hidden Video Element for MediaPipe -->
    <video id="video-input"></video>

    <!-- 3D Canvas Container is handled by Three.js -->

    <!-- Loading Indicator -->
    <div id="loading">Loading AI Models...</div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">Score: <span id="score">0</span></div>
            <div class="lives-box">Bombs: <span id="lives">❌ ❌ ❌</span></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen hidden">
        <h1>Cyber Slice 3D</h1>
        <p>Use your hand to slice fruits. Avoid the bombs!<br>Slice 3 bombs and it's Game Over.</p>
        <p style="font-size: 14px; color: #aaa; margin-top:10px;">Ensure good lighting. Show your index finger clearly.</p>
        <button id="btn-start">Start Game</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameover-screen" class="screen hidden">
        <h1 style="color: #ff4444; text-shadow: 0 0 20px #ff0000;">Game Over</h1>
        <p>Final Score: <span id="final-score" style="color:#ffd700; font-size: 30px; font-weight:bold;">0</span></p>
        <button id="btn-restart">Try Again</button>
    </div>

<script>
/**
 * CONFIGURATION & STATE
 */
const CONFIG = {
    cameraZ: 10,
    planeZ: 0,
    spawnInterval: 1000, // ms
    gravity: -9.8,
    colors: {
        trail: 0x00ffff,
        bomb: 0x111111,
        smoke: 0x555555
    }
};

const STATE = {
    isPlaying: false,
    score: 0,
    bombsHit: 0,
    maxBombs: 3,
    lastTime: 0,
    spawnTimer: 0,
    comboTimer: 0,
    comboCount: 0,
    cursor: { x: 0, y: 0, z: 0, active: false }, // World coordinates
    prevCursor: { x: 0, y: 0, z: 0 },
    width: window.innerWidth,
    height: window.innerHeight
};

// Arrays to hold active game entities
const entities = [];
const particles = [];

/**
 * AUDIO SYSTEM (Procedural - No external assets)
 */
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playSlice: function() {
        // High pitched swoosh
        this.playTone(600 + Math.random()*400, 'sawtooth', 0.1, 0.1);
    },
    playBomb: function() {
        // Low boom
        this.playTone(100, 'square', 0.5, 0.3);
        this.playTone(50, 'sine', 0.8, 0.5);
    },
    playGameOver: function() {
        this.playTone(300, 'sawtooth', 0.5, 0.2);
        setTimeout(() => this.playTone(250, 'sawtooth', 0.5, 0.2), 400);
        setTimeout(() => this.playTone(150, 'sawtooth', 1.0, 0.2), 800);
    }
};

/**
 * THREE.JS SETUP
 */
const scene = new THREE.Scene();
// Soft gradient background effect using fog
scene.fog = new THREE.FogExp2(0x1a1a1a, 0.02);

const camera = new THREE.PerspectiveCamera(60, STATE.width / STATE.height, 0.1, 100);
camera.position.z = CONFIG.cameraZ;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(STATE.width, STATE.height);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 7);
scene.add(dirLight);

// Determine visible world width/height at z=0 for coordinate mapping
const vFOV = THREE.MathUtils.degToRad(camera.fov);
const visibleHeight = 2 * Math.tan(vFOV / 2) * CONFIG.cameraZ;
const visibleWidth = visibleHeight * camera.aspect;

/**
 * ASSETS & HELPERS
 */

// Procedural Textures
function createSmokeTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16,16,0,16,16,16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,32,32);
    const tex = new THREE.CanvasTexture(canvas);
    return tex;
}
const smokeTexture = createSmokeTexture();

// Materials
const matFruitBase = new THREE.MeshStandardMaterial({ roughness: 0.1, metalness: 0.1 });
const matBomb = new THREE.MeshPhongMaterial({ color: CONFIG.colors.bomb, shininess: 100, emissive: 0x330000 });
const matSmoke = new THREE.PointsMaterial({ 
    size: 2, map: smokeTexture, transparent: true, opacity: 0.6, 
    depthWrite: false, color: CONFIG.colors.smoke 
});
const matTrail = new THREE.MeshBasicMaterial({ color: CONFIG.colors.trail, transparent: true, opacity: 0.5 });

/**
 * GAME CLASSES
 */

class Trail {
    constructor() {
        this.history = [];
        this.maxPoints = 10;
        this.geometry = new THREE.BufferGeometry();
        this.mesh = new THREE.Line(this.geometry, matTrail);
        scene.add(this.mesh);
    }
    update(x, y) {
        if(STATE.cursor.active) {
            this.history.push(new THREE.Vector3(x, y, 0));
            if (this.history.length > this.maxPoints) this.history.shift();
        } else {
            if(this.history.length > 0) this.history.shift();
        }
        this.geometry.setFromPoints(this.history);
    }
}
const cursorTrail = new Trail();

class ParticleSystem {
    constructor(x, y, color, count, type = 'juice') {
        this.type = type;
        this.geo = new THREE.BufferGeometry();
        const pos = [];
        const vel = [];
        
        for(let i=0; i<count; i++) {
            pos.push(x, y, 0);
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            vel.push(Math.cos(angle) * speed, Math.sin(angle) * speed, (Math.random()-0.5)*5);
        }
        
        this.geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        this.velocities = vel;
        
        if(type === 'smoke') {
            this.material = matSmoke.clone();
            this.mesh = new THREE.Points(this.geo, this.material);
        } else {
            this.material = new THREE.PointsMaterial({ color: color, size: 0.4, transparent: true });
            this.mesh = new THREE.Points(this.geo, this.material);
        }
        
        scene.add(this.mesh);
        this.life = 1.0;
    }

    update(dt) {
        this.life -= dt * (this.type === 'smoke' ? 0.8 : 2.0); // Smoke lasts longer
        const pos = this.geo.attributes.position.array;
        
        for(let i=0; i < this.velocities.length/3; i++) {
            const ix = i*3;
            pos[ix] += this.velocities[ix] * dt;
            pos[ix+1] += this.velocities[ix+1] * dt;
            pos[ix+2] += this.velocities[ix+2] * dt;
            
            // Gravity
            if(this.type !== 'smoke') this.velocities[ix+1] += CONFIG.gravity * dt;
            else {
                this.velocities[ix+1] += 2.0 * dt; // Smoke rises
                // Expand smoke
                pos[ix] += (Math.random()-0.5)*0.1;
            }
        }
        this.geo.attributes.position.needsUpdate = true;
        this.material.opacity = this.life;
        
        // Expand smoke particles visual size
        if(this.type === 'smoke') {
            this.material.size += dt * 5;
        }

        return this.life > 0;
    }

    dispose() {
        scene.remove(this.mesh);
        this.geo.dispose();
        this.material.dispose();
    }
}

class GameObject {
    constructor(isBomb) {
        this.isBomb = isBomb;
        this.radius = isBomb ? 0.8 : 0.6;
        this.sliced = false;
        
        // Visuals
        const geometry = isBomb 
            ? new THREE.IcosahedronGeometry(this.radius, 1) 
            : new THREE.SphereGeometry(this.radius, 16, 16);
            
        const color = isBomb ? 0x000000 : this.getRandomFruitColor();
        const mat = isBomb ? matBomb : matFruitBase.clone();
        if(!isBomb) mat.color.setHex(color);
        
        this.mesh = new THREE.Mesh(geometry, mat);
        this.mesh.colorHex = color; // Store for particles
        
        // Initial Physics
        // Spawn at bottom, random X
        const startX = (Math.random() - 0.5) * (visibleWidth * 0.6);
        this.mesh.position.set(startX, -visibleHeight/2 - 2, 0);
        
        // Upward velocity with random arc
        const vy = Math.random() * 5 + 12; // Vertical impulse
        const vx = (Math.random() - 0.5) * 4; // Horizontal drift
        // If spawning far left, drift right, and vice versa
        if (startX < -visibleWidth/4) this.velocity = new THREE.Vector3(Math.abs(vx), vy, 0);
        else if (startX > visibleWidth/4) this.velocity = new THREE.Vector3(-Math.abs(vx), vy, 0);
        else this.velocity = new THREE.Vector3(vx, vy, 0);

        // Rotation speed
        this.rotVelocity = new THREE.Vector3(Math.random(), Math.random(), Math.random());

        scene.add(this.mesh);
    }

    getRandomFruitColor() {
        const colors = [0xff0000, 0xffaa00, 0xffff00, 0x00ff00, 0xaa00ff];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    update(dt) {
        // Physics
        this.velocity.y += CONFIG.gravity * dt;
        this.mesh.position.addScaledVector(this.velocity, dt);
        this.mesh.rotation.x += this.rotVelocity.x * dt;
        this.mesh.rotation.y += this.rotVelocity.y * dt;

        // Bounds check (bottom)
        if (this.mesh.position.y < -visibleHeight/2 - 5) {
            return false; // Remove
        }
        return true;
    }

    slice(direction) {
        this.sliced = true;
        scene.remove(this.mesh);

        if (this.isBomb) {
            // Bomb Effect
            AudioSys.playBomb();
            // Smoke
            particles.push(new ParticleSystem(this.mesh.position.x, this.mesh.position.y, 0x555555, 20, 'smoke'));
            handleBombHit();
        } else {
            // Fruit Effect
            AudioSys.playSlice();
            addScore(10);
            
            // Juice Particles
            particles.push(new ParticleSystem(this.mesh.position.x, this.mesh.position.y, this.mesh.colorHex, 15));

            // Spawn two halves (visual trick)
            this.createHalf(direction, 1);
            this.createHalf(direction, -1);
        }
    }

    createHalf(sliceDir, side) {
        // Simple approximation: scaled spheres moving apart
        const geo = new THREE.SphereGeometry(this.radius * 0.9, 16, 16);
        const mat = this.mesh.material;
        const half = new THREE.Mesh(geo, mat);
        half.position.copy(this.mesh.position);
        
        // Separate perpendicular to slice direction
        const perp = new THREE.Vector3(-sliceDir.y, sliceDir.x, 0).normalize();
        half.position.addScaledVector(perp, side * 0.2);
        
        scene.add(half);
        
        // Add to entities as a "dead" object just to fall
        const obj = {
            mesh: half,
            velocity: this.velocity.clone().addScaledVector(perp, side * 2),
            update: (dt) => {
                obj.velocity.y += CONFIG.gravity * dt;
                obj.mesh.position.addScaledVector(obj.velocity, dt);
                obj.mesh.rotation.z += side * 5 * dt;
                if(obj.mesh.position.y < -visibleHeight/2 - 5) {
                    scene.remove(obj.mesh);
                    return false;
                }
                return true;
            }
        };
        entities.push(obj);
    }
}

/**
 * INPUT & LOGIC
 */

// Handle MediaPipe Hand Results
function onResults(results) {
    if (!STATE.isPlaying) return;

    // Hide loading if valid
    document.getElementById('loading').classList.add('hidden');

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const indexTip = landmarks[8]; // Index finger tip

        // Conversion: MediaPipe (0,0 top-left) -> Three.js World
        // X: 0..1 -> -visibleWidth/2 .. visibleWidth/2 (Mirrored: 1-x)
        // Y: 0..1 -> visibleHeight/2 .. -visibleHeight/2
        
        const rawX = (1 - indexTip.x) - 0.5; // Mirror and center
        const rawY = 0.5 - indexTip.y;       // Center

        const targetX = rawX * visibleWidth;
        const targetY = rawY * visibleHeight;

        STATE.prevCursor.x = STATE.cursor.x;
        STATE.prevCursor.y = STATE.cursor.y;

        // Smoothing (Lerp)
        STATE.cursor.x += (targetX - STATE.cursor.x) * 0.5;
        STATE.cursor.y += (targetY - STATE.cursor.y) * 0.5;
        STATE.cursor.active = true;

        checkCollisions();
    } else {
        STATE.cursor.active = false;
    }
}

function checkCollisions() {
    if(!STATE.cursor.active) return;

    const p1 = new THREE.Vector2(STATE.prevCursor.x, STATE.prevCursor.y);
    const p2 = new THREE.Vector2(STATE.cursor.x, STATE.cursor.y);
    const swipeVec = new THREE.Vector2().subVectors(p2, p1);
    const swipeLen = swipeVec.length();

    // Minimum speed to slice
    if (swipeLen < 0.1) return; 

    const dir = swipeVec.normalize();

    // Line Segment vs Circle collision (Simplified 2D check in 3D world plane)
    for (const entity of entities) {
        if (entity instanceof GameObject && !entity.sliced) {
            const pos = new THREE.Vector2(entity.mesh.position.x, entity.mesh.position.y);
            
            // Project point onto line segment
            const v = new THREE.Vector2().subVectors(pos, p1);
            const t = Math.max(0, Math.min(1, v.dot(swipeVec) / (swipeLen * swipeLen)));
            const projection = new THREE.Vector2().copy(p1).addScaledVector(swipeVec, t);
            
            const dist = pos.distanceTo(projection);
            
            if (dist < entity.radius) {
                entity.slice(dir);
            }
        }
    }
}

function spawnLogic(dt) {
    STATE.spawnTimer += dt;
    // Difficulty curve: spawn faster as score increases, capped at 400ms
    const currentInterval = Math.max(400, CONFIG.spawnInterval - (STATE.score * 5));
    
    if (STATE.spawnTimer > currentInterval / 1000) {
        STATE.spawnTimer = 0;
        
        // Chance for Bomb: increases slightly with score, max 20%
        const bombChance = Math.min(0.2, 0.05 + (STATE.score * 0.001));
        const isBomb = Math.random() < bombChance;
        
        entities.push(new GameObject(isBomb));
    }
}

/**
 * GAME CONTROL
 */

function addScore(points) {
    STATE.score += points;
    document.getElementById('score').innerText = STATE.score;
}

function handleBombHit() {
    STATE.bombsHit++;
    
    // Update HUD
    const livesStr = "❌ ".repeat(STATE.maxBombs - STATE.bombsHit);
    document.getElementById('lives').innerText = livesStr;

    // Camera shake
    const shake = setInterval(() => {
        camera.position.x = (Math.random() - 0.5) * 0.5;
        camera.position.y = (Math.random() - 0.5) * 0.5;
    }, 16);
    setTimeout(() => {
        clearInterval(shake);
        camera.position.set(0, 0, CONFIG.cameraZ);
    }, 300);

    if (STATE.bombsHit >= STATE.maxBombs) {
        gameOver();
    }
}

function startGame() {
    STATE.isPlaying = true;
    STATE.score = 0;
    STATE.bombsHit = 0;
    STATE.spawnTimer = 0;
    entities.forEach(e => scene.remove(e.mesh));
    entities.length = 0;
    particles.forEach(p => p.dispose());
    particles.length = 0;
    
    document.getElementById('score').innerText = '0';
    document.getElementById('lives').innerText = '❌ ❌ ❌';
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('gameover-screen').classList.add('hidden');
    
    AudioSys.init();
}

function gameOver() {
    STATE.isPlaying = false;
    AudioSys.playGameOver();
    document.getElementById('final-score').innerText = STATE.score;
    document.getElementById('gameover-screen').classList.remove('hidden');
}

/**
 * MAIN LOOP
 */
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    
    const dt = clock.getDelta();

    if (STATE.isPlaying) {
        spawnLogic(dt);
        cursorTrail.update(STATE.cursor.x, STATE.cursor.y);
    } else {
        // Idle animation for trail
        cursorTrail.update(STATE.cursor.x, STATE.cursor.y);
    }

    // Update Entities
    for (let i = entities.length - 1; i >= 0; i--) {
        const alive = entities[i].update(dt);
        if (!alive) {
            scene.remove(entities[i].mesh);
            entities.splice(i, 1);
        }
    }

    // Update Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const alive = particles[i].update(dt);
        if (!alive) {
            particles[i].dispose();
            particles.splice(i, 1);
        }
    }

    renderer.render(scene, camera);
}

/**
 * INITIALIZATION
 */
const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});
hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});
hands.onResults(onResults);

const videoElement = document.getElementById('video-input');
const cameraObj = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 640,
    height: 480
});

// Start camera but wait for user to click "Start" for game logic
cameraObj.start();

// UI Listeners
document.getElementById('btn-start').addEventListener('click', startGame);
document.getElementById('btn-restart').addEventListener('click', startGame);

// Handle Resize
window.addEventListener('resize', () => {
    STATE.width = window.innerWidth;
    STATE.height = window.innerHeight;
    camera.aspect = STATE.width / STATE.height;
    camera.updateProjectionMatrix();
    renderer.setSize(STATE.width, STATE.height);
});

// Kick off render loop
animate();

</script>
</body>
</html>

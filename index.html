<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Optimized 3D Hand-Track Fruit Ninja</title>
<style>
  body { margin:0; overflow:hidden; background:#111; font-family:Segoe UI, Roboto, Arial; }
  canvas { display:block; }
  #video-input { position:absolute; top:0; left:0; opacity:0; pointer-events:none; z-index:-1; }

  #ui-layer { position:absolute; inset:0; pointer-events:none; display:flex; flex-direction:column; justify-content:space-between; }
  .hud-top { display:flex; justify-content:space-between; padding:18px; font-size:20px; color:#fff; font-weight:700; text-shadow:0 2px 6px rgba(0,0,0,0.6); pointer-events:none; }
  .score-box span { color:#ffd700; }
  .lives-box span { color:#ff4444; font-size:22px; }

  .screen { position:absolute; inset:0; background:rgba(0,0,0,0.75); display:flex; flex-direction:column; align-items:center; justify-content:center; pointer-events:auto; z-index:10; }
  h1 { color:#fff; font-size:48px; margin:0 0 10px 0; letter-spacing:4px; text-transform:uppercase; }
  p { color:#ddd; max-width:640px; text-align:center; }
  button { margin-top:18px; padding:12px 32px; font-size:18px; background:linear-gradient(45deg,#ff0055,#ff9900); border:none; color:#fff; border-radius:40px; cursor:pointer; }
  #loading { color:#fff; position:absolute; left:50%; top:20px; transform:translateX(-50%); font-size:14px; }
</style>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<video id="video-input" playsinline></video>

<div id="loading">Loading AI models...</div>

<div id="ui-layer">
  <div class="hud-top">
    <div class="score-box">Score: <span id="score">0</span></div>
    <div class="lives-box">Bombs: <span id="lives">❌ ❌ ❌</span></div>
  </div>
</div>

<!-- Start Screen (visible at load) -->
<div id="start-screen" class="screen">
  <h1>Cyber Slice 3D</h1>
  <p>Use your index fingertip to slice fruits. Avoid bombs — slicing 3 bombs ends the game.<br>Make sure you're in good lighting and keep your hand mostly inside the camera view.</p>
  <button id="btn-start">Start Game</button>
</div>

<div id="gameover-screen" class="screen hidden" style="display:none;">
  <h1 style="color:#ff4444;">Game Over</h1>
  <p>Final Score: <span id="final-score" style="color:#ffd700; font-weight:700;">0</span></p>
  <button id="btn-restart">Try Again</button>
</div>

<script>
/* ======================
   CONFIG & STATE
   ====================== */
const CONFIG = {
  cameraZ: 10,
  gravity: -9.8,
  spawnIntervalMs: 1000,
  maxEntities: 18,         // Soft cap on fruits/bombs active
  poolSize: 24,            // pool of reusable meshes
  maxParticles: 120,       // total particle items active
  throttleHandsMs: 33,     // ~30fps hand detection
  pixelRatioCap: 1.5
};

const STATE = {
  playing: false,
  score: 0,
  bombsHit: 0,
  maxBombs: 3,
  spawnAccumulatorMs: 0,
  lastHandSend: 0,
  cursor: { x:0, y:0, active:false },
  prevCursor: { x:0, y:0 },
  width: window.innerWidth,
  height: window.innerHeight
};

/* ======================
   BASIC AUDIO (procedural light)
   ====================== */
const AudioSys = {
  ctx: null,
  init() { try { window.AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); } catch(e) {} },
  tone(freq, t=0.08, type='sine', vol=0.08) {
    if(!this.ctx) return;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(this.ctx.destination);
    o.start(); o.stop(this.ctx.currentTime + t);
    g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + t);
  },
  slice(){ this.tone(700 + Math.random()*300, 0.08, 'sawtooth', 0.06); },
  bomb(){ this.tone(120, 0.35, 'square', 0.18); this.tone(60, 0.7, 'sine', 0.1); },
  gameOver(){ this.tone(300,0.4,'sawtooth',0.12); setTimeout(()=>this.tone(220,0.6,'sawtooth',0.12),300); }
};

/* ======================
   THREE SETUP
   ====================== */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0d0d0d, 0.025);

const camera = new THREE.PerspectiveCamera(60, STATE.width/STATE.height, 0.1, 100);
camera.position.z = CONFIG.cameraZ;

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, CONFIG.pixelRatioCap));
renderer.setSize(STATE.width, STATE.height);
renderer.sortObjects = false; // small perf win
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambient);
const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(3,6,4); scene.add(dir);

/* Compute visible area at z=0 for mapping screen coords to world coords */
function computeVisible() {
  const vFOV = THREE.MathUtils.degToRad(camera.fov);
  const height = 2 * Math.tan(vFOV/2) * camera.position.z;
  const width = height * camera.aspect;
  return { width, height };
}
let visible = computeVisible();

/* ======================
   Reusable temporaries (avoid per-frame allocations)
   ====================== */
const TMP = {
  v2a: new THREE.Vector2(),
  v2b: new THREE.Vector2(),
  swipeVec: new THREE.Vector2(),
  proj: new THREE.Vector2(),
  worldPos: new THREE.Vector3()
};

/* ======================
   POOLS: GameObject and Particle pools (minimal)
   ====================== */
const Pools = {
  meshes: [],
  particleSystems: []
};

/* Create simple textures for smoke / particle (canvas) */
function makeRadialTexture(size=32, inner='rgba(255,255,255,1)', outer='rgba(255,255,255,0)') {
  const c = document.createElement('canvas'); c.width = c.height = size;
  const ctx = c.getContext('2d');
  const g = ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
  g.addColorStop(0, inner); g.addColorStop(1, outer);
  ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(c);
}
const smokeTex = makeRadialTexture(48, 'rgba(200,200,200,0.9)', 'rgba(200,200,200,0)');

/* Materials (reuse) */
const matFruit = new THREE.MeshStandardMaterial({ roughness:0.25, metalness:0.05 });
const matBomb = new THREE.MeshPhongMaterial({ color:0x000000, shininess:80, emissive:0x220000 });
const trailMat = new THREE.LineBasicMaterial({ color:0x00ffff, transparent:true, opacity:0.45 });
const smokeMat = new THREE.PointsMaterial({ map: smokeTex, sizeAttenuation:true, transparent:true, opacity:0.6, depthWrite:false });

/* Pool initialization: pre-create low-detail meshes */
function initPool() {
  const sphereGeom = new THREE.SphereGeometry(0.6, 8, 8); // lower detail
  const bombGeom = new THREE.IcosahedronGeometry(0.78, 0);

  for(let i=0;i<CONFIG.poolSize;i++){
    // Fruit mesh clone
    const m = new THREE.Mesh(sphereGeom, matFruit.clone());
    m.userData.inUse = false;
    m.visible = false;
    scene.add(m);
    Pools.meshes.push(m);

    // Also create a lightweight "slice half" geometry reused later if needed (we'll fake halves with scaled spheres)
  }
  // Particles pool (simple small Points that we reuse)
  for(let i=0;i<Math.ceil(CONFIG.maxParticles/6);i++){
    const geo = new THREE.BufferGeometry();
    const maxP = 8; // per pool item
    const pos = new Float32Array(maxP * 3);
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const p = new THREE.Points(geo, smokeMat.clone());
    p.userData.inUse = false;
    p.visible = false;
    scene.add(p);
    Pools.particleSystems.push({ points: p, maxP });
  }
}
initPool();

/* Helper to get a free mesh from pool */
function getMesh(isBomb=false) {
  for(const m of Pools.meshes){
    if(!m.userData.inUse){
      m.userData.inUse = true;
      m.visible = true;
      // swap material if bomb
      if(isBomb) {
        m.geometry = new THREE.IcosahedronGeometry(0.78,0); // small allocation but okay on spawn
        m.material = matBomb;
      } else {
        m.geometry = new THREE.SphereGeometry(0.6, 8, 8);
        m.material = matFruit.clone();
      }
      return m;
    }
  }
  return null; // no free meshes
}

function releaseMesh(m) {
  if(!m) return;
  m.userData.inUse = false;
  m.visible = false;
  // don't dispose geometry here; reuse if possible
}

/* Particle helper: reuse a pooled Points object and initialize positions/velocities */
function spawnParticles(x,y,color=0xffffff,count=10,type='juice') {
  // Limit how many particle systems active
  let ps = null;
  for(const p of Pools.particleSystems){
    if(!p.points.userData.inUse){ ps = p; break; }
  }
  if(!ps) return; // out of particle budget

  ps.points.userData.inUse = true;
  ps.points.visible = true;
  ps.type = type;
  ps.life = type === 'smoke' ? 1.4 : 0.7;
  const maxP = ps.maxP;
  const positions = ps.points.geometry.attributes.position.array;
  ps.vel = new Float32Array(maxP*3);

  // initialize
  for(let i=0;i<maxP;i++){
    const idx = i*3;
    positions[idx] = x;
    positions[idx+1] = y;
    positions[idx+2] = 0;
    const angle = Math.random()*Math.PI*2;
    const speed = (type==='smoke') ? (Math.random()*0.4 + 0.1) : (Math.random()*2.5 + 0.6);
    ps.vel[idx] = Math.cos(angle)*speed;
    ps.vel[idx+1] = Math.sin(angle)*speed;
    ps.vel[idx+2] = (Math.random()-0.5)*0.6;
  }
  ps.points.geometry.attributes.position.needsUpdate = true;
  // color tint for non-smoke
  if(type !== 'smoke') ps.points.material = new THREE.PointsMaterial({ size:0.12, color: color, transparent:true });
  else ps.points.material = smokeMat.clone();

  // add to active particles list
  Active.particles.push(ps);
}

/* Release particle system back to pool */
function releaseParticles(ps) {
  if(!ps) return;
  ps.points.userData.inUse = false;
  ps.points.visible = false;
  // keep geometry for reuse
}

/* ======================
   GameObject class (lightweight, stores a mesh from pool)
   ====================== */
class GameObject {
  constructor(mesh, isBomb=false) {
    this.mesh = mesh;
    this.isBomb = isBomb;
    this.radius = isBomb ? 0.78 : 0.6;
    this.sliced = false;
    this.velocity = new THREE.Vector3();
    this.rotVel = new THREE.Vector3();
  }
  initAt(x,y, vx, vy) {
    this.mesh.position.set(x,y,0);
    this.mesh.rotation.set(Math.random(), Math.random(), Math.random());
    this.velocity.set(vx, vy, 0);
    this.rotVel.set(Math.random()*2, Math.random()*2, Math.random()*2);
    this.sliced = false;
  }
  update(dt) {
    if(this.sliced) {
      // if sliced we simply let it fall
    }
    this.velocity.y += CONFIG.gravity * dt;
    this.mesh.position.addScaledVector(this.velocity, dt);
    this.mesh.rotation.x += this.rotVel.x * dt;
    this.mesh.rotation.y += this.rotVel.y * dt;
    // bottom removal
    if(this.mesh.position.y < -visible.height/2 - 6) return false;
    return true;
  }
  slice(dir) {
    if(this.sliced) return;
    this.sliced = true;
    // play effects
    if(this.isBomb) {
      AudioSys.bomb();
      spawnParticles(this.mesh.position.x, this.mesh.position.y, 0x666666, 8, 'smoke');
      handleBombHit();
    } else {
      AudioSys.slice();
      addScore(10);
      spawnParticles(this.mesh.position.x, this.mesh.position.y, this.mesh.material.color.getHex ? this.mesh.material.color.getHex() : 0xffcc00, 8, 'juice');

      // create two falling halves cheaply: clone mesh but scale and give opposite velocity
      const halfA = getMesh(false);
      const halfB = getMesh(false);
      if(halfA && halfB) {
        // reuse meshes as halves (briefly)
        halfA.position.copy(this.mesh.position); halfB.position.copy(this.mesh.position);
        halfA.scale.set(0.85,0.9,0.9); halfB.scale.set(0.85,0.9,0.9);
        halfA.material = this.mesh.material.clone(); halfB.material = this.mesh.material.clone();
        // add temporary Entity wrappers for halves
        Active.entities.push({
          mesh: halfA,
          velocity: this.velocity.clone().add(new THREE.Vector3(dir.y * 2, 2.5, 0)),
          rot: (Math.random()*6 + 2),
          update(dt) {
            this.velocity.y += CONFIG.gravity * dt;
            this.mesh.position.addScaledVector(this.velocity, dt);
            this.mesh.rotation.z += this.rot * dt;
            if(this.mesh.position.y < -visible.height/2 - 6) {
              releaseMesh(this.mesh);
              return false;
            }
            return true;
          }
        });
        Active.entities.push({
          mesh: halfB,
          velocity: this.velocity.clone().add(new THREE.Vector3(-dir.y * 2, 2.5, 0)),
          rot: -(Math.random()*6 + 2),
          update(dt) {
            this.velocity.y += CONFIG.gravity * dt;
            this.mesh.position.addScaledVector(this.velocity, dt);
            this.mesh.rotation.z += this.rot * dt;
            if(this.mesh.position.y < -visible.height/2 - 6) {
              releaseMesh(this.mesh);
              return false;
            }
            return true;
          }
        });
      }
    }
    // hide original mesh and release soon
    releaseMesh(this.mesh);
  }
}

/* Active lists (not pools) */
const Active = { entities: [], particles: [] };

/* Reusable spawn function that uses pools. Returns true if spawned. */
function spawnEntity(isBomb=false) {
  // enforce cap
  if(Active.entities.length >= CONFIG.maxEntities) return false;
  const mesh = getMesh(isBomb);
  if(!mesh) return false; // no free mesh

  // spawn pos at bottom with random X within visible width
  const startX = (Math.random() - 0.5) * visible.width * 0.66;
  const startY = -visible.height/2 - 2.2;
  const vy = Math.random()*5 + 12;
  let vx = (Math.random() - 0.5) * 3.6;
  if(startX < -visible.width/4) vx = Math.abs(vx);
  else if(startX > visible.width/4) vx = -Math.abs(vx);

  const go = new GameObject(mesh, isBomb);
  go.initAt(startX, startY, vx, vy);
  // store for collision checking
  Active.entities.push(go);
  return true;
}

/* ======================
   Cursor Trail (lightweight)
   ====================== */
class Trail {
  constructor() {
    this.points = [];
    this.max = 12;
    this.geometry = new THREE.BufferGeometry();
    this.line = new THREE.Line(this.geometry, trailMat);
    scene.add(this.line);
  }
  update(x,y,active) {
    if(active) {
      this.points.push(x,y,0);
      if(this.points.length/3 > this.max) this.points.splice(0,3);
    } else {
      if(this.points.length>0) this.points.splice(0,3);
    }
    const arr = new Float32Array(this.points);
    this.geometry.setAttribute('position', new THREE.BufferAttribute(arr,3));
    this.geometry.attributes.position.needsUpdate = true;
  }
}
const trail = new Trail();

/* ======================
   Collision detection (optimized)
   ====================== */
/* Helper: project world point (x,y in world plane) to same coords we use for cursor (world) - we already use world coords for cursor */
function checkCollisionsOptimized() {
  if(!STATE.cursor.active) return;
  TMP.v2a.set(STATE.prevCursor.x, STATE.prevCursor.y);
  TMP.v2b.set(STATE.cursor.x, STATE.cursor.y);
  TMP.swipeVec.subVectors(TMP.v2b, TMP.v2a);
  const swipeLen = TMP.swipeVec.length();
  if(swipeLen < 0.8) return; // require some movement

  // normalized direction
  const dir = TMP.swipeVec.clone().normalize();

  // iterate Active.entities backward (safe removal pattern)
  for(let i = Active.entities.length - 1; i >= 0; i--) {
    const ent = Active.entities[i];
    if(ent instanceof GameObject) {
      if(ent.sliced) continue;
      TMP.proj.set(ent.mesh.position.x, ent.mesh.position.y);
      // compute segment projection t
      const v = TMP.proj.clone().sub(TMP.v2a);
      const t = Math.max(0, Math.min(1, v.dot(TMP.swipeVec) / (swipeLen*swipeLen)));
      const projection = TMP.v2a.clone().add(TMP.swipeVec.clone().multiplyScalar(t));
      const dist = TMP.proj.distanceTo(projection);
      if(dist < ent.radius * 0.95) {
        // slice found
        ent.slice(dir);
      }
    } else {
      // plain object wrapper (halves). Keep simple: they have mesh property and update function
    }
  }
}

/* ======================
   HUD updates (only when changed)
   ====================== */
let lastScore = -1, lastLives = -1;
function syncHUD() {
  if(STATE.score !== lastScore) {
    document.getElementById('score').innerText = STATE.score;
    lastScore = STATE.score;
  }
  const livesLeft = Math.max(0, STATE.maxBombs - STATE.bombsHit);
  if(livesLeft !== lastLives) {
    document.getElementById('lives').innerText = '❌ '.repeat(livesLeft);
    lastLives = livesLeft;
  }
}

/* ======================
   Spawn logic (time-based, ms)
   ====================== */
function spawnLogic(deltaMs) {
  STATE.spawnAccumulatorMs += deltaMs;
  const currentInterval = Math.max(400, CONFIG.spawnIntervalMs - (STATE.score * 4)); // faster as score grows
  if(STATE.spawnAccumulatorMs >= currentInterval) {
    STATE.spawnAccumulatorMs = 0;
    // spawn one or two
    const bombProb = Math.min(0.18, 0.05 + (STATE.score * 0.0012));
    if(Math.random() < bombProb) spawnEntity(true);
    else spawnEntity(false);
  }
}

/* ======================
   Score & bomb handlers
   ====================== */
function addScore(points) {
  STATE.score += points;
}
function handleBombHit() {
  STATE.bombsHit++;
  // camera shake light
  const orig = camera.position.clone();
  let t = 0;
  const shInt = setInterval(()=> {
    camera.position.x = orig.x + (Math.random()-0.5)*0.25;
    camera.position.y = orig.y + (Math.random()-0.5)*0.25;
  }, 30);
  setTimeout(()=> {
    clearInterval(shInt);
    camera.position.copy(orig);
  }, 260);
  AudioSys.bomb();
  if(STATE.bombsHit >= STATE.maxBombs) {
    gameOver();
  }
}

/* ======================
   Game control
   ====================== */
function resetGameState() {
  STATE.score = 0;
  STATE.bombsHit = 0;
  STATE.spawnAccumulatorMs = 0;
  Active.entities.forEach(e => {
    if(e.mesh) releaseMesh(e.mesh);
  });
  Active.entities.length = 0;
  // release particles
  for(const p of Active.particles) releaseParticles(p);
  Active.particles.length = 0;
  // reset HUD trackers
  lastScore = -1; lastLives = -1;
  syncHUD();
}

function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('gameover-screen').style.display = 'none';
  STATE.playing = true;
  resetGameState();
  AudioSys.init();
}

function gameOver() {
  STATE.playing = false;
  AudioSys.gameOver();
  document.getElementById('final-score').innerText = STATE.score;
  document.getElementById('gameover-screen').style.display = 'flex';
}

/* UI listeners */
document.getElementById('btn-start').addEventListener('click', startGame);
document.getElementById('btn-restart').addEventListener('click', startGame);

/* ======================
   MediaPipe HANDS Setup (throttled)
   ====================== */
const videoElement = document.getElementById('video-input');
const hands = new Hands({ locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands:1, modelComplexity:0, minDetectionConfidence:0.6, minTrackingConfidence:0.5 });
hands.onResults((res) => {
  // if not playing, still update loading / cursor for visual
  if(res.multiHandLandmarks && res.multiHandLandmarks.length) {
    const lm = res.multiHandLandmarks[0][8]; // index tip
    const rawX = (1 - lm.x) - 0.5; // mirror & center
    const rawY = 0.5 - lm.y;
    const targetX = rawX * visible.width;
    const targetY = rawY * visible.height;
    // smooth lerp into cursor (avoid huge jumps)
    STATE.prevCursor.x = STATE.cursor.x;
    STATE.prevCursor.y = STATE.cursor.y;
    STATE.cursor.x += (targetX - STATE.cursor.x) * 0.5;
    STATE.cursor.y += (targetY - STATE.cursor.y) * 0.5;
    STATE.cursor.active = true;
    document.getElementById('loading').style.display = 'none';
  } else {
    STATE.cursor.active = false;
  }
});

// camera utils with throttled sending
const cameraObj = new Camera(videoElement, {
  onFrame: async () => {
    const now = performance.now();
    if(now - STATE.lastHandSend >= CONFIG.throttleHandsMs) {
      STATE.lastHandSend = now;
      await hands.send({ image: videoElement });
    }
  },
  width: 640, height: 480
});
cameraObj.start();

/* ======================
   MAIN LOOP
   ====================== */
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const dtMs = dt * 1000;

  // Update visible if window changed (small cost)
  visible = computeVisible();

  // spawn logic only while playing
  if(STATE.playing) {
    spawnLogic(dtMs);
  }

  // update trail
  trail.update(STATE.cursor.x, STATE.cursor.y, STATE.cursor.active);

  // update entities (Active.entities may contain GameObject or halves wrapper)
  for(let i = Active.entities.length - 1; i >= 0; i--) {
    const ent = Active.entities[i];
    const alive = ent.update(dt);
    if(!alive) {
      // if ent is GameObject we already released mesh on slice; ensure release
      if(ent instanceof GameObject) {
        releaseMesh(ent.mesh);
      } else if(ent.mesh) {
        releaseMesh(ent.mesh);
      }
      Active.entities.splice(i,1);
    }
  }

  // update active particle systems
  for(let i = Active.particles.length - 1; i >= 0; i--) {
    const ps = Active.particles[i];
    ps.life -= dt;
    const positions = ps.points.geometry.attributes.position.array;
    for(let j=0;j<ps.maxP;j++){
      const idx = j*3;
      positions[idx] += ps.vel[idx] * dt;
      positions[idx+1] += ps.vel[idx+1] * dt;
      positions[idx+2] += ps.vel[idx+2] * dt;
      if(ps.type === 'smoke') {
        ps.vel[idx+1] += 0.12 * dt; // gentle rise
      } else {
        ps.vel[idx+1] += CONFIG.gravity * dt * 0.2;
      }
    }
    ps.points.geometry.attributes.position.needsUpdate = true;
    ps.points.material.opacity = Math.max(0, ps.life/1.4);

    if(ps.life <= 0) {
      releaseParticles(ps);
      Active.particles.splice(i,1);
    }
  }

  // collisions (only when playing)
  if(STATE.playing) checkCollisionsOptimized();

  // update HUD less frequently
  syncHUD();

  renderer.render(scene, camera);
}
animate();

/* ======================
   Collision trigger bound to input: we use a small interval to check swipe on mouse too (for dev)
   ====================== */
let lastSwipeCheck = 0;
setInterval(()=> {
  if(!STATE.playing) return;
  // We do collision check in animate, but we can also do a slightly higher-frequency check here if needed.
  // (Left empty intentionally for now - collisions live in main loop)
}, 50);

/* ======================
   Resize handling
   ====================== */
window.addEventListener('resize', () => {
  STATE.width = window.innerWidth; STATE.height = window.innerHeight;
  camera.aspect = STATE.width / STATE.height; camera.updateProjectionMatrix();
  renderer.setSize(STATE.width, STATE.height);
});

/* ======================
   Simple debug: allow click/touch to simulate slice for quick testing
   ====================== */
let mouseDown = false;
window.addEventListener('pointerdown', (e) => { mouseDown = true; updateCursorFromPointer(e); });
window.addEventListener('pointerup', () => { mouseDown = false; STATE.cursor.active = false; });
window.addEventListener('pointermove', (e) => { if(mouseDown) updateCursorFromPointer(e); });
function updateCursorFromPointer(e) {
  // map pointer to world coords
  const nx = (e.clientX / STATE.width) - 0.5;
  const ny = 0.5 - (e.clientY / STATE.height);
  STATE.prevCursor.x = STATE.cursor.x; STATE.prevCursor.y = STATE.cursor.y;
  STATE.cursor.x = nx * visible.width;
  STATE.cursor.y = ny * visible.height;
  STATE.cursor.active = true;
}

/* ======================
   Start: unhide start-screen by default & hide loading when ready
   ====================== */
document.getElementById('start-screen').style.display = 'flex';
document.getElementById('loading').style.display = 'block';
/* small ready check: hide loading after models appear (hands.onResults handles) */

</script>
</body>
</html>
